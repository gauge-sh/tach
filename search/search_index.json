{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tach","text":"<p>\u26a0\ufe0f UNMAINTAINED: This repository is no longer actively maintained. Issues and pull requests may not receive a response.</p> <p>Tach is a tool that helps you control dependencies between your Python modules. It allows modules to define explicit public interfaces to prevent deep coupling, creating a more modular architecture.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udf0e Open source</li> <li>\ud83d\udc0d Installable via pip</li> <li>\ud83d\udd27 Able to be adopted incrementally</li> <li>\u26a1 Implemented with no runtime impact</li> <li>\u267e\ufe0f Interoperable with your existing systems (cli, hooks, ci, etc.)</li> </ul>"},{"location":"#how-it-works","title":"How it Works","text":"<p>Tach checks that no module imports from another module that is not listed as a dependency. When a module has a public interface, any import which does not go through the public interface will cause Tach to report an error.</p> <p>Dependencies can be additionally marked as 'deprecated', in which case Tach will surface their usage without reporting an error.</p>"},{"location":"#core-commands","title":"Core Commands","text":"<ul> <li><code>tach init</code> - Interactively define module boundaries.</li> <li><code>tach check</code> - Check that boundaries and interfaces are respected.</li> <li><code>tach sync</code> - Sync constraints with the actual dependencies in your project.</li> <li><code>tach show</code> - Visualize your project's dependency graph.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to get started with Tach? Check out our Getting Started Guide or the Overview to learn more. </p>"},{"location":"contributing/setting-up-project/","title":"Setup Guide","text":""},{"location":"contributing/setting-up-project/#1-automated-dependency-installation","title":"1. Automated dependency installation","text":"<p>Installing all the dependencies <pre><code> make deps\n</code></pre></p>"},{"location":"contributing/setting-up-project/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/setting-up-project/#issue-python-command-not-found","title":"Issue: <code>python: command not found</code>","text":"<p>On some systems, the <code>make deps</code> command may fail with an error stating that the <code>python</code> command is not found. This happens because some systems only provide <code>python3</code> and do not include a <code>python</code> symlink.</p>"},{"location":"contributing/setting-up-project/#macos-fix","title":"macOS Fix:","text":"<p>If you're on macOS, create a symbolic link for <code>python</code> pointing to <code>python3</code>:</p> <pre><code>sudo ln -s $(which python3) /usr/local/bin/python\n</code></pre>"},{"location":"contributing/setting-up-project/#linux-fix","title":"Linux Fix:","text":"<pre><code>sudo ln -s $(which python3) /usr/bin/python\n</code></pre>"},{"location":"contributing/setting-up-project/#windows-fix","title":"Windows Fix:","text":"<p>On Windows, ensure Python is installed and added to your <code>PATH</code>. You can check by running:</p> <pre><code>python --version\n</code></pre> <p>If <code>python</code> is not recognized, use the <code>python3</code> command instead, or create an alias in PowerShell:</p> <pre><code>Set-Alias -Name python -Value python3\n</code></pre> <p>After applying the appropriate fix, retry:</p> <pre><code>make deps\n</code></pre>"},{"location":"contributing/setting-up-project/#2-build","title":"2. Build","text":"<p>To build and rebuild after changes to Rust files.</p> <p>Note</p> <p>Make sure you have the Rust compiler installed. This package requires Rust and Cargo to compile extensions.</p>"},{"location":"contributing/setting-up-project/#install-the-crate-as-module-in-the-current-virtualenv","title":"Install the crate as module in the current virtualenv","text":"<pre><code>make install\n</code></pre>"},{"location":"contributing/setting-up-project/#3-test","title":"3. Test","text":"<p>Tach internally uses <code>pytest</code> module for testing all the files within <code>python/tests/</code> <pre><code>make test\n</code></pre></p>"},{"location":"contributing/setting-up-project/#4-setting-up-the-docs","title":"4. Setting up the docs","text":"<p>Tach uses MkDocs with the Material theme for documentation. To work with the documentation:</p> <ol> <li> <p>Install the documentation dependencies: <pre><code>pip install -r docs/requirements.txt\n</code></pre></p> </li> <li> <p>Start the local development server: <pre><code>mkdocs serve\n</code></pre></p> </li> <li> <p>Open your browser to http://127.0.0.1:8000/ to see the documentation.</p> </li> </ol> <p>For more details, see Working with Docs.</p>"},{"location":"contributing/setting-up-project/#5-things-to-check-before-committing","title":"5. Things to check before committing","text":"<p>Check and sync your dependencies in the root folder <pre><code>tach check\ntach sync\n</code></pre> Type checking <pre><code>make type-check\n</code></pre> Run linting checks for Rust and Python code <pre><code>make lint\n</code></pre> Format Rust and Python code <pre><code>make fmt\n</code></pre></p> <p>That's it! You are now ready to push your new dev branch to your forked repo and then raise a PR with appropriate description</p> <p>Find Beginner Friendly issues here:  - Good First Issues (For beginners) - Documentation Issues - Issues - Documentation</p>"},{"location":"contributing/working-with-docs/","title":"Working with Documentation","text":"<p>This guide explains how to work with Tach's documentation system, which uses MkDocs with the Material theme.</p>"},{"location":"contributing/working-with-docs/#prerequisites","title":"Prerequisites","text":"<p>You need Python installed on your system and the documentation dependencies:</p> <pre><code>pip install -r docs/requirements.txt\n</code></pre>"},{"location":"contributing/working-with-docs/#local-development","title":"Local Development","text":"<p>To work on the documentation locally, run:</p> <pre><code>mkdocs serve\n</code></pre> <p>This will start a local server at http://127.0.0.1:8000/ with live reloading.</p>"},{"location":"contributing/working-with-docs/#documentation-structure","title":"Documentation Structure","text":"<p>The documentation is organized as follows:</p> <ul> <li><code>docs/index.md</code> - Home page</li> <li><code>docs/getting-started/</code> - Getting started guides</li> <li><code>docs/usage/</code> - Usage documentation</li> <li><code>docs/contributing/</code> - Contributing guides</li> <li><code>docs/assets/</code> - Images and other assets</li> </ul>"},{"location":"contributing/working-with-docs/#adding-new-pages","title":"Adding New Pages","text":"<p>To add a new page:</p> <ol> <li>Create a new Markdown file (<code>.md</code>) in the appropriate directory</li> <li>Add an entry to the <code>nav</code> section in <code>mkdocs.yml</code></li> </ol> <p>Example:</p> <pre><code>nav:\n  - Home: index.md\n  - Getting Started:\n    - Overview: getting-started/introduction.md\n    - # Add your new page here\n    - My New Page: getting-started/my-new-page.md\n</code></pre>"},{"location":"contributing/working-with-docs/#formatting","title":"Formatting","text":"<p>MkDocs uses Markdown for formatting. Some useful features with Material for MkDocs include:</p>"},{"location":"contributing/working-with-docs/#code-blocks","title":"Code Blocks","text":"<pre><code>def example_function():\n    return \"Hello, World!\"\n</code></pre>"},{"location":"contributing/working-with-docs/#admonitions","title":"Admonitions","text":"<p>Note</p> <p>This is a note admonition.</p> <p>Warning</p> <p>This is a warning admonition.</p> <p>Tip</p> <p>This is a tip admonition.</p>"},{"location":"contributing/working-with-docs/#tabs","title":"Tabs","text":"Tab 1Tab 2 <p>Content for tab 1</p> <p>Content for tab 2</p>"},{"location":"contributing/working-with-docs/#images","title":"Images","text":"<p>Place images in the <code>docs/assets/</code> directory and reference them like this:</p> <pre><code>![Alt text](../assets/image-name.png)\n</code></pre>"},{"location":"contributing/working-with-docs/#deployment","title":"Deployment","text":"<p>The documentation is automatically deployed to GitHub Pages when changes are pushed to the main branch. The deployment is handled by the GitHub Actions workflow in <code>.github/workflows/docs.yml</code>. </p>"},{"location":"getting-started/getting-started/","title":"Getting Started","text":""},{"location":"getting-started/getting-started/#installation","title":"Installation","text":"<p>Tach can be installed via pip:</p> <pre><code>pip install tach\n</code></pre>"},{"location":"getting-started/getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/getting-started/#1-initialize-your-project","title":"1. Initialize Your Project","text":"<pre><code>tach init\n</code></pre> <p>This will guide you through setting up your module boundaries and will create a <code>tach.toml</code> file in your project root.</p>"},{"location":"getting-started/getting-started/#2-define-module-boundaries","title":"2. Define Module Boundaries","text":"<p>Use the interactive module editor to define your module boundaries:</p> <pre><code>tach mod\n</code></pre> <p>This opens an interactive terminal UI where you can navigate and mark your module boundaries:</p> <ul> <li>Use arrow keys to navigate the file tree</li> <li>Press <code>Enter</code> to mark/unmark a module</li> <li>Press <code>s</code> to mark a directory as a source root</li> <li>Press <code>u</code> to mark a module as a utility module (can be used anywhere)</li> <li>Press <code>Ctrl+a</code> to mark all siblings as modules</li> <li>Press <code>Ctrl+s</code> to save</li> <li>Press <code>Ctrl+c</code> to exit without saving</li> </ul>"},{"location":"getting-started/getting-started/#3-sync-dependencies","title":"3. Sync Dependencies","text":"<p>Once your module boundaries are defined, sync your dependency rules with your actual code:</p> <pre><code>tach sync\n</code></pre> <p>This will analyze your codebase and automatically add dependency rules to your <code>tach.toml</code> file based on your actual imports.</p>"},{"location":"getting-started/getting-started/#4-check-boundaries","title":"4. Check Boundaries","text":"<p>Now you can check if your module boundaries are respected:</p> <pre><code>tach check\n</code></pre> <p>This command will report any violations of your module boundaries or interfaces.</p>"},{"location":"getting-started/getting-started/#5-visualize-dependencies","title":"5. Visualize Dependencies","text":"<p>To see a visualization of your module dependencies:</p> <pre><code>tach show\n</code></pre> <p>This will generate a graphical representation of your module dependencies.</p>"},{"location":"getting-started/getting-started/#integrating-with-your-development-workflow","title":"Integrating with Your Development Workflow","text":""},{"location":"getting-started/getting-started/#pre-commit-hook","title":"Pre-commit Hook","text":"<p>You can add Tach to your pre-commit hooks to automatically check your module boundaries on each commit:</p> <pre><code>tach install --pre-commit\n</code></pre> <p>Or manually add it to your <code>.pre-commit-config.yaml</code>:</p> <pre><code>-   repo: local\n    hooks:\n    -   id: tach\n        name: tach\n        entry: tach check\n        language: system\n        pass_filenames: false\n</code></pre>"},{"location":"getting-started/getting-started/#ci-pipeline","title":"CI Pipeline","text":"<p>Add Tach to your CI pipeline to ensure your module boundaries are respected:</p> <pre><code>- name: Check module boundaries\n  run: tach check\n</code></pre>"},{"location":"getting-started/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about Configuration</li> <li>Explore the Commands in detail</li> <li>Define Public Interfaces for your modules</li> <li>Set up Layers to enforce architectural patterns </li> </ul>"},{"location":"getting-started/introduction/","title":"Overview","text":""},{"location":"getting-started/introduction/#what-is-tach","title":"What is Tach?","text":"<p>Tach allows you to control dependencies between your Python modules. Modules can also define an explicit public interface to prevent deep coupling.</p> <p>This creates a modular architecture, which makes development easier.</p> <p>If a module tries to import from another module that is not listed as a dependency, Tach will report an error.</p> <p>When a module has a public interface, any import which does not go through the public interface will cause Tach to report an error.</p> <p>Dependencies can be additionally marked as 'deprecated'. Tach will not report an error but will surface usages of the deprecated dependency.</p> <p>Tach is a CLI tool, and is ideal for pre-commit hooks and CI checks.</p> <p>Tach is:</p> <ul> <li>\ud83c\udf0e Open source</li> <li>\ud83d\udc0d Installable via pip</li> <li>\ud83d\udd27 Able to be adopted incrementally</li> <li>\u26a1 Implemented with no runtime impact</li> <li>\u267e\ufe0f Interoperable with your existing systems (cli, hooks, ci, etc.)</li> </ul>"},{"location":"getting-started/introduction/#commands","title":"Commands","text":"<ul> <li><code>tach init</code> - Initialize your project and select module boundaries</li> <li><code>tach mod</code> - Interactively edit module boundaries.</li> <li><code>tach check</code> - Check that boundaries and interfaces are respected.</li> <li><code>tach check-external</code> - Check 3rd party imports match dependencies in your packages.</li> <li><code>tach sync</code> - Sync constraints with the actual dependencies in your project.</li> <li><code>tach show</code> - Visualize your project's dependency graph.</li> <li><code>tach map</code> - Generate a JSON dependency map between files in your codebase.</li> <li><code>tach report</code> - Generate a dependency report for a file or module.</li> <li><code>tach test</code> - Run only the tests impacted by your changes</li> <li><code>tach install</code> - Install Tach into your development workflow (e.g. pre-commit) </li> </ul>"},{"location":"getting-started/why-tach/","title":"Why Tach?","text":""},{"location":"getting-started/why-tach/#modern-codebases-are-complex","title":"Modern Codebases are Complex","text":"<p>Many Python projects start as small, simple scripts. But over time, they tend to grow into a complex web of thousands of modules, with messy dependencies that can cause bugs and slow down development.</p> <p>Large Python codebases become especially difficult when:</p> <ul> <li>Refactoring is risky because dependencies are opaque</li> <li>Adding features becomes a fearful experience</li> <li>Changes have unknown ripple effects</li> <li>Teams need boundaries between code areas</li> <li>Module APIs aren't explicit </li> </ul>"},{"location":"getting-started/why-tach/#existing-solutions-fall-short","title":"Existing Solutions Fall Short","text":"<p>There are some existing tools for managing Python dependencies:</p> <ul> <li>Type checkers: Help catch issues with dynamic typing, but don't enforce module boundaries</li> <li>Linters: Can alert on styling issues, but don't generally analyze module structure</li> <li>Package managers: Manage external dependencies, but don't handle internal module dependencies</li> <li>Tests: Verify functionality, but don't enforce architecture</li> <li>Manually managed dependency rules: Hard to maintain and inconsistent</li> </ul>"},{"location":"getting-started/why-tach/#tach-is-purpose-built-for-modularity","title":"Tach is Purpose-Built for Modularity","text":"<p>Tach is designed to solve this specific problem. It gives you tools to:</p> <ul> <li>Define module boundaries in your codebase</li> <li>Control dependencies between modules</li> <li>Define explicit public interfaces to prevent deep coupling</li> <li>Gradually adopt in existing projects</li> <li>Integrate with your workflow: CI, pre-commit, etc.</li> </ul> <p>Tach helps you build and maintain a modular Python architecture that can scale with your project as it grows. </p>"},{"location":"usage/caching/","title":"Caching","text":"<p>Tach makes use of a 'computation cache' to speed up certain tasks, such as testing.</p> <p>When Tach finds cached results for a given task, the terminal output is enclosed in:</p> <pre><code>============ Cached results found!  ============\n...\n============ END Cached results  ============\n</code></pre> <p>Caching is done at the command level. This means a single invocation of <code>tach test</code> can only ever result in a single cache hit or miss. Individual tests are not cached separately.</p>"},{"location":"usage/caching/#cache-content","title":"Cache content","text":"<p>The computation cache contains the output from <code>stdout</code> and <code>stderr</code> from a previous task invocation.</p> <p>This is done to enable 'replaying' cached tasks so that their output can be reused seamlessly.</p>"},{"location":"usage/caching/#determining-cache-hits","title":"Determining cache hits","text":"<p>Tach uses several pieces of information to determine cache hits:</p> <ul> <li>Python interpreter version (<code>major.minor.micro</code>)</li> <li>All Python file contents beneath your source roots</li> <li>Declared versions of 3rd party dependencies in project requirements (<code>requirements.txt</code> or <code>pyproject.toml</code>)</li> <li>File contents of explicitly configured file dependencies</li> <li>Explicitly configured environment variable values</li> </ul> <p>When all of these match a previous cache entry, the cached results are printed directly to the terminal.</p>"},{"location":"usage/caching/#cache-storage","title":"Cache storage","text":"<p>The computation cache exists within the <code>.tach</code> directory in your project root. The directory is managed by Tach, and your cached results are stored on-disk on each machine where tasks are run.</p> <p>We are currently working on a remote cache backend, which will allow multiple developers and CI environments to share a centralized cache to maximize the hit rate. If you are interested in this functionality, reach out through a GitHub issue or via email: evan@gauge.sh; caelean@gauge.sh!</p>"},{"location":"usage/caching/#disabling-the-cache","title":"Disabling the cache","text":"<p>The computation cache is enabled by default for commands such as tach test. It can be disabled using <code>--disable-cache</code>. This will prevent all access to the cache and run the underlying command unconditionally.</p>"},{"location":"usage/commands/","title":"Commands","text":""},{"location":"usage/commands/#tach-init","title":"tach init","text":"<p>Tach provides a guided setup process in <code>tach init</code>. This command will provide guidance and perform validation, while walking through <code>tach mod</code>, <code>tach sync</code> and <code>tach show</code>.</p> <p>New users should start with this command.</p> <pre><code>usage: tach init [-h] [--force]\n\nInitialize a new project\n\noptions:\n  -h, --help  show this help message and exit\n  --force     Force re-initialization if project is already configured.\n</code></pre>"},{"location":"usage/commands/#tach-mod","title":"tach mod","text":"<p>Tach provides an interactive editor for configuring your module boundaries - <code>tach mod</code>.</p> <pre><code>usage: tach mod [-h] [-d [DEPTH]] [-e file_or_path,...]\n\nConfigure module boundaries interactively\n\noptions:\n  -h, --help            show this help message and exit\n  -d [DEPTH], --depth [DEPTH]\n                        The number of child directories to expand from the root\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>Running <code>tach mod</code> will open an editor in your terminal where you can mark your module boundaries.</p> <p>You can navigate with the arrow keys, mark individual modules with <code>Enter</code>, and mark all siblings as modules with <code>Ctrl + a</code>.</p> <p>You can also mark your Python source roots by pressing <code>s</code>. This allows Tach to understand module paths and correctly identify first-party imports.</p> <p>You can mark modules as utilities by pressing <code>u</code>. This is appropriate for modules like <code>utils/</code>, which can be freely used by the rest of the code.</p> <p>To save your modules, use <code>Ctrl + s</code>. Otherwise, to exit without saving, use <code>Ctrl + c</code>.</p> <p>Any time you make changes with <code>tach mod</code>, run <code>tach sync</code> to automatically configure dependency rules.</p>"},{"location":"usage/commands/#tach-sync","title":"tach sync","text":"<p>Tach can automatically sync your project configuration (<code>tach.toml</code>) with your project's actual dependencies.</p> <pre><code>usage: tach sync [-h] [--add] [-e file_or_path,...]\n\nSync constraints with actual dependencies in your project.\n\noptions:\n  -h, --help            show this help message and exit\n  --add                 add all existing constraints and re-sync dependencies.\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>When this command runs, Tach will analyze the imports in your Python project.</p> <p>Any undeclared dependencies will be automatically resolved by adding the corresponding dependencies to your <code>tach.toml</code> file.</p> <p>With <code>--add</code>, any missing dependencies in your <code>tach.toml</code> will be added, but does not remove unused dependencies.</p> <p>When run without the <code>--add</code> flag, <code>tach sync</code> will remove modules from the <code>tach.yml</code> file that do not exist in the project's source roots.</p>"},{"location":"usage/commands/#tach-check","title":"tach check","text":"<p>Tach will flag any unwanted imports between modules. We recommend you run <code>tach check</code> like a linter or test runner, e.g. in pre-commit hooks, on-save hooks, and in CI pipelines.</p> <pre><code>usage: tach check [-h] [--exact] [--dependencies] [--interfaces] [-e file_or_path,...]\n\nCheck existing boundaries against your dependencies and module interfaces\n\noptions:\n  -h, --help            show this help message and exit\n  --exact               When checking dependencies, raise errors if any dependencies are unused.\n  --dependencies        Check dependency constraints between modules. When present, all checks must be explicitly enabled.\n  --interfaces          Check interface implementations. When present, all checks must be explicitly enabled.\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>Using the <code>--dependencies</code> or <code>--interfaces</code> flag will limit the checks performed to the respective category. By default, all checks will be performed.</p>"},{"location":"usage/commands/#dependency-errors","title":"Dependency Errors","text":"<p>An error will indicate:</p> <ul> <li>the file path in which the error was detected</li> <li>the module associated with that file</li> <li>the module associated with the attempted import</li> </ul> <p>If <code>--exact</code> is provided, additional errors will be raised if a dependency exists in <code>tach.toml</code> that does not exist in the code.</p> <p>Example:</p> <pre><code>&gt; tach check\n\u274c tach/check.py[L8]: Cannot import 'tach.filesystem'. Module 'tach' cannot depend on 'tach.filesystem'.\n</code></pre> <p>NOTE: If your terminal supports hyperlinks, you can click on the failing file path to go directly to the error.</p>"},{"location":"usage/commands/#interface-errors","title":"Interface Errors","text":"<p>An error will indicate:</p> <ul> <li>the file path in which the error was detected</li> <li>the module associated with that file</li> <li>the module associated with the attempted import</li> <li>the non-public member associated with the attempted import</li> </ul> <p>Example:</p> <pre><code>\u274c  tach/mod.py[L13]: Module 'tach.interactive' has a defined public interface. Only imports from the public interface of this module are allowed. The import 'tach.interactive.get_selected_modules_interactive' (in module 'tach.mod') is not public.\n</code></pre> <p>NOTE: If your terminal supports hyperlinks, you can click on the failing file path to go directly to the error.</p>"},{"location":"usage/commands/#tach-check-external","title":"tach check-external","text":"<p>Tach can validate that the external imports in your Python packages match your declared package dependencies in <code>pyproject.toml</code> or <code>requirements.txt</code>.</p> <pre><code>usage: tach check-external [-h] [-e file_or_path,...]\n\nPerform checks related to third-party dependencies\n\noptions:\n  -h, --help  show this help message and exit\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>For all Python files in each source root, Tach will determine which package it belongs to, and compare its dependencies to those declared in <code>pyproject.toml</code> or <code>requirements.txt</code>. Tach will report an error for any external import which is not satisfied by the declared dependencies.</p> <p>This also means that, for monorepos which contain multiple Python packages, Tach will detect when an import comes from a source root in another package, and verify that this dependency is declared. Make sure to configure <code>source_roots</code> for every package (globs are coming soon!).</p> <p>This is typically useful if you are developing more than one Python package from a single virtual environment. Although your local environment may contain the dependencies for all your packages, when an end-user installs each package they will only install the dependencies listed in the <code>pyproject.toml</code>.</p> <p>This means that, although tests may pass in your shared environment, an invalid import can still cause errors at runtime for your users.</p> <p>In case you would like to explicitly allow a certain external module, this can be configured in your <code>tach.toml</code></p> <p>Note</p> <pre><code>It is recommended to run Tach within a virtual environment containing all of\n</code></pre> <p>your dependencies across all packages. This is because Tach uses the   distribution metadata to map module names like 'git' to their distributions   ('GitPython').</p>"},{"location":"usage/commands/#tach-report","title":"tach report","text":"<p>Tach can generate a report showing all the dependencies and usages of a given module.</p> <pre><code>usage: tach report [-h] [--dependencies] [--usages] [--external] [-d module_path,...] [-u module_path,...] [--raw] [-e file_or_path,...] path\n\nCreate a report of dependencies and usages.\n\npositional arguments:\n  path                  The path or directory path used to generate the report.\n\noptions:\n  -h, --help            show this help message and exit\n  --dependencies        Generate dependency report. When present, all reports must be explicitly enabled.\n  --usages              Generate usage report. When present, all reports must be explicitly enabled.\n  --external            Generate external dependency report. When present, all reports must be explicitly enabled.\n  -d module_path,..., --dependency-modules module_path,...\n                        Comma separated module list of dependencies to include [includes everything by default]\n  -u module_path,..., --usage-modules module_path,...\n                        Comma separated module list of usages to include [includes everything by default]\n  --raw                 Group lines by module and print each without any formatting.\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>By default, this will generate a textual report showing the file and line number of each module dependency, module usage, and external dependency. Each section corresponds to a command line flag.</p> <p>The given <code>path</code> can be a directory or a file path. The module which contains the given path will be used to determine which imports to include in the report. Generally, if an import points to a file which is contained by a different module, it will be included.</p> <p>The <code>--dependencies</code> flag includes module dependencies, meaning any import which targets a different module within your project. For example, if <code>core.api</code> and <code>core.services</code> are marked as modules, then an import of <code>core.api.member</code> from within <code>core.services</code> would be included in a report for <code>core/services</code>.</p> <p>The <code>--usages</code> flag includes module usages, meaning any import which comes from a different module within your project. For example, if <code>core.api</code> and <code>core.services</code> are marked as modules, then an import of <code>core.services.member</code> from within <code>core.api</code> would be included in a report for <code>core/services</code>.</p> <p>The <code>--external</code> flag includes external (3rd party) dependencies, meaning any import which targets a module outside of your project. For example, importing <code>pydantic</code> or <code>tomli</code> would be included in this report.</p> <p>Note</p> <pre><code>It is recommended to run Tach within a virtual environment containing all of\n</code></pre> <p>your dependencies across all packages. This is because Tach uses the   distribution metadata to map 3rd party module names like 'git' to their distributions   ('GitPython').</p> <p>Supplying the <code>--raw</code> flag will group the results by module name and eliminate formatting, making the output more easily machine-readable.</p>"},{"location":"usage/commands/#tach-show","title":"tach show","text":"<p>Tach will generate a visual representation of your dependency graph!</p> <pre><code>usage: tach show [-h] [--web] [--mermaid] [-o [OUT]] [included_paths ...]\n\nVisualize the dependency graph of your project.\n\npositional arguments:\n  included_paths        Paths to include in the module graph. If not provided, the entire project is\n                        included.\n\noptions:\n  -h, --help            show this help message and exit\n  --web                 Open your dependency graph in a remote web viewer.\n  --mermaid             Generate a mermaid.js graph instead of a DOT file.\n  -o [OUT], --out [OUT]\n                        Specify an output path for a locally generated module graph file.\n</code></pre> <p>These are the results of <code>tach show --web</code> on the Tach codebase itself: </p>"},{"location":"usage/commands/#tach-map","title":"tach map","text":"<p>Tach can generate a JSON dependency map showing the relationships between files in your project. <pre><code>usage: tach map [-h] [-o OUTPUT] [--direction {dependencies,dependents}] [--closure CLOSURE]\n\nBuild a dependency map and write it to a file or stdout\n\noptions:\n  -h, --help            show this help message and exit\n  -o OUTPUT, --output OUTPUT\n                        Output file path. Use '-' for stdout (default: '-')\n  --direction {dependencies,dependents}\n                        Direction of the map (default: 'dependencies')\n  --closure CLOSURE     Get the closure for a specific file path\n</code></pre></p> <p>By default, <code>tach map</code> outputs to stdout and shows dependencies. The output is a JSON object where each key is a file path and its value is an array of file paths it depends on.</p> <p>Example output: <pre><code>{\n  \"src/core.py\": [\"src/utils.py\", \"src/config.py\"],\n  \"src/utils.py\": [],\n  \"src/config.py\": [\"src/utils.py\"]\n}\n</code></pre></p> <p>This map is particularly useful for build tools, test runners, and development servers that need to understand file dependencies.</p> <p>For example, it can help with test selection by identifying affected files, or support hot-reloading by finding all files that need to be reloaded when a dependency changes.</p>"},{"location":"usage/commands/#with-jq","title":"With jq","text":"<p>You can use <code>jq</code> to query this output. Here are some useful examples:</p> <pre><code># Get dependencies for a specific file\ntach map | jq '.\"src/core.py\"'\n\n# Find all files that depend on utils.py (using dependents direction)\ntach map --direction dependents | jq '.\"src/utils.py\"'\n\n# Count dependencies for each file\ntach map | jq 'map_values(length)'\n\n# Find files with no dependencies\ntach map | jq 'to_entries | map(select(.value | length == 0)) | map(.key)'\n</code></pre>"},{"location":"usage/commands/#closures","title":"Closures","text":"<p>The <code>--closure</code> flag can be used to find all transitive dependencies for a specific file path. For example:</p> <pre><code># Get all direct and indirect dependencies of core.py\ntach map --closure src/core.py\n</code></pre> <p>Example output with closure: <pre><code>[\n  \"src/core.py\",\n  \"src/utils.py\",\n  \"src/config.py\",\n  \"src/constants.py\"\n]\n</code></pre></p> <p>The output includes the target file itself and all files that are either directly or indirectly required by it. In this example, if <code>src/core.py</code> imports <code>config.py</code> which in turn imports <code>constants.py</code>, all of these files will appear in the closure.</p>"},{"location":"usage/commands/#tach-test","title":"tach test","text":"<p>Tach also functions as an intelligent test runner.</p> <pre><code>usage: tach test [-h] [--base [BASE]] [--head [HEAD]] [--disable-cache] ...\nRun tests on modules impacted by the current changes.\npositional arguments:\n  pytest_args      Arguments forwarded to pytest. Use '--' to separate\n                   these arguments. Ex: 'tach test -- -v'\noptions:\n  -h, --help       show this help message and exit\n  --base [BASE]    The base commit to use when determining which modules\n                   are impacted by changes. [default: 'main']\n  --head [HEAD]    The head commit to use when determining which modules\n                   are impacted by changes. [default: current filesystem]\n  --disable-cache  Do not check cache for results, and\n                   do not push results to cache.\n</code></pre> <p>Using <code>pytest</code>, running <code>tach test</code> will perform impact analysis on the changes between your current filesystem and your <code>main</code> branch to determine which test files need to be run. This can dramatically speed up your test suite in CI, particularly when you make a small change to a large codebase. This command also takes advantage of Tach's computation cache.</p>"},{"location":"usage/commands/#tach-install","title":"tach install","text":"<p>Tach can be installed into your development workflow automatically as a pre-commit hook.</p>"},{"location":"usage/commands/#with-pre-commit-framework","title":"With pre-commit framework","text":"<p>If you use the pre-commit framework, you can add the following to your <code>.pre-commit-hooks.yaml</code>:</p> <pre><code>repos:\n  - repo: https://github.com/gauge-sh/tach-pre-commit\n    rev: v0.30.0 # change this to the latest tag!\n    hooks:\n      - id: tach\n</code></pre> <p>Note that you should specify the version you are using in the <code>rev</code> key.</p>"},{"location":"usage/commands/#standard-install","title":"Standard install","text":"<p>If you don't already have pre-commit hooks set up, you can run:</p> <pre><code>tach install pre-commit\n</code></pre> <p>The command above will install <code>tach check</code> as a pre-commit hook, directly into <code>.git/hooks/pre-commit</code>.</p> <p>If that file already exists, you will need to manually add <code>tach check</code> to your existing <code>.git/hooks/pre-commit</code> file.</p>"},{"location":"usage/configuration/","title":"Configuration","text":"<p>Aside from running <code>tach mod</code> and <code>tach sync</code>, you can configure Tach by creating or modifying the configuration file as described below.</p>"},{"location":"usage/configuration/#tachtoml","title":"<code>tach.toml</code>","text":"<p>This is the project-level configuration file which should be in the root of your project.</p> <p><code>modules</code> defines the modules in your project - see details.</p> <p><code>interfaces</code> defines the interfaces of modules in your project (optional) - see details.</p> <p><code>layers</code> defines the layers of modules in your project (optional) - see details.</p> <p><code>exclude</code> accepts a list of directory patterns to exclude from checking. These should be glob paths which match from the beginning of a given file path. For example: <code>project/*.tests</code> would match any path beginning with <code>project/</code> and ending with <code>.tests</code>.</p> <p>Note</p> <pre><code>Tach uses forward slashes to match path separators, even on Windows.\n</code></pre> <p><code>ignore_type_checking_imports</code> (default: true) is a flag which silences <code>tach check</code> failures caused by imports under a <code>TYPE_CHECKING</code> conditional block.</p> <p><code>exact</code> (default: false) is a flag which causes <code>tach check</code> to fail if any declared dependencies are found to be unused.</p> <p><code>forbid_circular_dependencies</code> (default: false) is a flag which causes <code>tach check</code> to fail if any circular dependencies are detected.</p> <p><code>respect_gitignore</code> (default: true) is a flag which causes Tach to exclude files and directories matched by <code>.gitignore</code>.</p> <p><code>root_module</code> takes a string enum value, and determines how Tach treats code which lives within the project but is not covered by an explicit module. This is described in detail below</p> <p><code>rules</code> allows precise configuration of the severity of certain types of issues. See below for more details.</p> <pre><code>exclude = [\n    \"**/*__pycache__\",\n    \"build/\",\n    \"dist/\",\n    \"docs/\",\n    \"python/tests/\",\n    \"tach.egg-info/\",\n    \"venv/\",\n]\nsource_roots = [\"python\"]\nexact = true\nignore_type_checking_imports = true\nforbid_circular_dependencies = true\n\nlayers = [\n  \"ui\",\n  \"commands\",\n  \"core\"\n]\n\n[[modules]]\npath = \"tach\"\ndepends_on = []\n\n[[modules]]\npath = \"tach.__main__\"\nlayer = \"ui\"\n\n[[modules]]\npath = \"tach.errors\"\ndepends_on = []\nutility = true\n\n[[modules]]\npath = \"tach.parsing\"\ndepends_on = [\"tach\", \"tach.filesystem\"]\nlayer = \"core\"\nvisibility = [\"tach.check\"]\n\n[[modules]]\npath = \"tach.check\"\ndepends_on = [\n    \"tach.extension\",\n    \"tach.filesystem\",\n    \"tach.parsing\",\n]\nlayer = \"commands\"\n\n[[interfaces]]\nexpose = [\"types.*\"]\n\n[[interfaces]]\nexpose = [\n    \"parse_project_config\",\n    \"dump_project_config_to_toml\",\n]\nfrom = [\n    \"tach.parsing\",\n]\n\n...\n\n[cache]\nfile_dependencies = [\"python/tests/**\", \"src/*.rs\"]\n\n[external]\nexclude = [\"pytest\"]\n\n[rules]\nunused_ignore_directives = \"warn\"\n</code></pre>"},{"location":"usage/configuration/#modules","title":"Modules","text":"<p>Each module listed under the <code>modules</code> key above can accept the following attributes:</p> <ul> <li><code>path</code> the Python import path to the module (e.g. <code>a.b</code> for <code>&lt;root&gt;/a/b.py</code>)</li> </ul> <p>Note</p> <pre><code>Glob patterns are allowed. The pattern `\"libs.**\"` would define the default configuration for any module under the `libs` namespace.&lt;br/&gt;&lt;br/&gt;This can be overridden for specific modules by defining them later in the file using a concrete pattern like `\"libs.module\"`.\n</code></pre> <p>Note</p> <pre><code>A module can also define `paths` as a shorthand for multiple module definitions. This allows specifying allowed dependencies and other attributes as a group.&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;Example: `paths = [\"a.b\", \"a.c\"]`\n</code></pre> <ul> <li><code>depends_on</code> a list of module paths which this module can import from</li> </ul> <p>Note</p> <pre><code>Glob patterns are allowed. The pattern `\"libs.**\"` would allow dependencies on any module under the `libs` namespace.\n</code></pre> <p>Note</p> <pre><code>Omitting the `depends_on` field means the module will be allowed to import from any other module. However, it will still be subject to those modules' [public interfaces](#interfaces).\n</code></pre> <ul> <li><code>cannot_depend_on</code> a list of module paths which this module cannot import from</li> </ul> <p>Note</p> <pre><code>This takes precedence over `depends_on`. In other words, if `cannot_depend_on = [\"module\"]`, then `depends_on = [\"module\"]` will have no effect.\n</code></pre> <ul> <li><code>layer</code> (optional) the layer which holds this module</li> <li><code>visibility</code> (optional) a list of other modules which can import from this module</li> <li><code>utility</code> (default: <code>false</code>) marks this module as a Utility, meaning all other modules may import from it without declaring an explicit dependency</li> <li><code>unchecked</code> (default: <code>false</code>) marks this module as unchecked, meaning Tach will not check its imports</li> </ul> <p>Note</p> <pre><code>Tach also supports [deprecating individual dependencies](deprecate.md).\n</code></pre>"},{"location":"usage/configuration/#interfaces","title":"Interfaces","text":"<p>Public interfaces are defined separately from modules, and define the imports that are allowed from that module.</p> <p>For example, if a module should expose everything from a nested 'services' folder, the config would look like:</p> <pre><code>[[interfaces]]\nexpose = [\"services.*\"]\nfrom = [\"my_module\"]\n</code></pre> <p>More specifically:</p> <ul> <li><code>expose</code>: a list of regex patterns which define the public interface</li> <li><code>from</code> (optional): a list of regex patterns which define the modules which adopt this interface</li> <li><code>visibility</code> (optional): a list of modules which can use this interface</li> <li><code>exclusive</code> (default: <code>false</code>): when paired with <code>visibility</code>, requires that matching modules use only this interface</li> </ul> <p>More details here.</p> <p>Note</p> <pre><code>If an interface entry does not specify `from`, all modules will adopt the interface.\n</code></pre> <p>Note</p> <pre><code>A module can match multiple interface entries - if an import matches _any_ of the entries, it will be considered valid.\n</code></pre>"},{"location":"usage/configuration/#layers","title":"Layers","text":"<p>An ordered list of layers can be configured at the top level of <code>tach.toml</code>, and modules can each be assigned to a specific layer.</p> <pre><code>layers = [\n  \"ui\",\n  \"commands\",\n  \"core\"\n]\n\n[[modules]]\npath = \"tach.check\"\nlayer = \"commands\"\n\n[[modules]]\npath = \"tach.cache\"\nlayer = \"core\"\n</code></pre> <p>The configuration above defines three layers, with <code>ui</code> being the highest layer, and <code>core</code> being the lowest layer. It also tags <code>tach.check</code> as a module in the <code>commands</code> layer, and <code>tach.cache</code> in <code>core</code>.</p> <p>More details here.</p>"},{"location":"usage/configuration/#the-root-module","title":"The Root Module","text":"<p>By default, Tach checks all of the source files beneath all of the configured source roots, and will ignore dependencies which are not contained by modules.</p> <p>However, Tach allows configuration of how to treat code which is within a source root, but not contained by a module.</p> <p>For example, given the file tree below:</p> <pre><code>my_repo/\n  tach.toml\n  script.py\n  lib/\n    module1.py\n    module2/\n      __init__.py\n      service.py\n    module3.py\n  docs/\n  tests/\n</code></pre> <p>If <code>lib.module1</code>, <code>lib.module2</code>, and <code>lib.module3</code> are the only configured modules, then the code in <code>script.py</code> would be automatically part of the <code>&lt;root&gt;</code> module.</p> <p>This module can declare its own dependencies with <code>depends_on</code> and use the rest of the available module configuration. Further, other modules would need to declare an explicit dependency on <code>&lt;root&gt;</code> to use code which rolls up to the root.</p> <p>Tach allows configuring how the root module should be treated through the <code>root_module</code> key in <code>tach.toml</code>. It may take one of the following values:</p> <ul> <li>(permissive default) <code>\"ignore\"</code>: Disable all checks related to the <code>&lt;root&gt;</code> module. <code>tach check</code> will never fail due to code in the <code>&lt;root&gt;</code> module, and <code>tach sync</code> will never add <code>&lt;root&gt;</code> to <code>tach.toml</code></li> <li>(stricter) <code>\"allow\"</code>: Treat <code>&lt;root&gt;</code> as a catch-all rollup module which must be explicitly declared as a dependency and must declare its own dependencies on other modules.</li> <li>(stricter) <code>\"dependenciesonly\"</code>: Forbid any module from listing <code>&lt;root&gt;</code> as a dependency, but allow <code>&lt;root&gt;</code> to declare its own dependencies.</li> <li>(strictest) <code>\"forbid\"</code>: Forbid any reference to the <code>&lt;root&gt;</code> module in tach.toml. This means that all code in source roots MUST be contained within an explicitly configured module.</li> </ul>"},{"location":"usage/configuration/#source-roots","title":"Source Roots","text":"<p>The <code>source_roots</code> key is required for Tach to understand the imports within your project. If it is not set explicitly, <code>source_roots</code> defaults to your project root path: <code>['.']</code>. This means Tach will expect that your Python imports are resolved relative to the directory in which <code>tach.toml</code> exists.</p> <p>Below are typical cases in which modifying <code>source_roots</code> is necessary.</p>"},{"location":"usage/configuration/#example-python-below-project-root","title":"Example: Python below project root","text":"<p>Suppose your repository contains a subfolder where all of your Python code lives. This could be a web server, a collection of serverless functions, or even utility scripts. In this example we will assume the Python code in our repo lives in the <code>backend/</code> folder.</p> <pre><code>my_repo/\n  tach.toml\n  backend/\n    module1.py\n    module2/\n      __init__.py\n      service.py\n    module3.py\n  docs/\n  tests/\n</code></pre> <p>In a Python module such as <code>backend/module1.py</code>, we can see imports from other modules.</p> <pre><code># In backend/module1.py\n\nimport module3\nfrom module2.service import MyService\n</code></pre> <p>Notice that these import paths (<code>module3</code>, <code>module2.service.MyService</code>) are rooted in the <code>backend/</code> folder, NOT the project root.</p> <p>To indicate this structure to Tach, set:</p> <pre><code>source_roots = [\"backend\"]\n</code></pre> <p>in your <code>tach.toml</code>, or use <code>tach mod</code> and mark the <code>backend</code> folder as the only source root.</p>"},{"location":"usage/configuration/#example-monorepo-namespace-packages","title":"Example: Monorepo - Namespace Packages","text":"<p>Suppose you work on a 'monorepo', in which Python packages which import from each other are located in distinct project directories. You may package your utility libraries in a <code>utility</code>folder, while your core packages live in <code>core_one</code> and <code>core_two</code>. You may also use a namespace package to share a common top-level namespace. In this example we'll use <code>myorg</code> as the namespace package.</p> <p>The file tree in a case like this might look like:</p> <pre><code>my_repo/\n  tach.toml\n  utility/\n    pyproject.toml\n    src/\n      myorg/\n        utils/\n          __init__.py\n  core_one/\n    pyproject.toml\n    src/\n      myorg/\n        core_one/\n          __init__.py\n          module1.py\n          module2/\n            __init__.py\n            service.py\n          module3.py\n  core_two/\n    pyproject.toml\n    src/\n      myorg/\n        core_two/\n          __init__.py\n          module1.py\n          module2/\n            __init__.py\n            service.py\n          module3.py\n  docs/\n  tests/\n</code></pre> <p>In a Python module such as <code>core_one/src/myorg/core_one/module1.py</code>, there may be imports from other packages:</p> <pre><code># In core_one/src/myorg/core_one/module1.py\n\nfrom myorg.utils import utility_fn\n</code></pre> <p>Notice that this import path (<code>myorg.utils.utility_fn</code>) is rooted in the <code>utility/src</code> folder, NOT the project root.</p> <p>To indicate the project structure to Tach, you would set:</p> <pre><code>source_roots = [\n  \"utility/src\",\n  \"core_one/src\",\n  \"core_two/src\"\n]\n</code></pre> <p>in your <code>tach.toml</code>, or use <code>tach mod</code> and mark the same folders as source roots.</p> <p>Note</p> <pre><code>In `tach.toml`, each entry in `source_roots` is interpreted as a relative path from the project root.\n</code></pre> <p>After configuring your source roots as above, you can use <code>tach check-external</code> to validate that any dependencies between the packages are declared explicitly in the corresponding <code>pyproject.toml</code>.</p> <p>For example, given the import shown above (<code>core_one</code> importing from <code>utility</code>),</p> <pre><code># In core_one/src/myorg/core_one/module1.py\n\nfrom myorg.utils import utility_fn\n</code></pre> <p>Tach would validate that this is declared in <code>core_one/pyproject.toml</code>:</p> <pre><code># In core_one/pyproject.toml\n[project]\ndependencies = [\"myorg-utility\"]\n</code></pre> <p>Note that this also assumes the <code>name</code> of the <code>utility</code> package has been set to <code>myorg-utility</code>:</p> <pre><code># In utility/pyproject.toml\n[project]\nname = \"myorg-utility\"\n</code></pre>"},{"location":"usage/configuration/#example-monorepo-workspace-packages","title":"Example: Monorepo - Workspace Packages","text":"<p>Suppose you work on a 'monorepo', in which Python packages which import from each other are located in distinct project directories. You may package your utility libraries in a <code>utility</code>folder, while your core packages live in <code>core_one</code> and <code>core_two</code>. You may also use something like uv workspaces to organize these packages.</p> <p>The file tree in a case like this might look like:</p> <pre><code>my_repo/\n  tach.toml\n  utility/\n    pyproject.toml\n    src/\n      utility/\n        __init__.py\n  core_one/\n    pyproject.toml\n    src/\n      core_one/\n        __init__.py\n        module1.py\n        module2/\n          __init__.py\n          service.py\n        module3.py\n  core_two/\n    pyproject.toml\n    src/\n      core_two/\n        __init__.py\n        module1.py\n        module2/\n          __init__.py\n          service.py\n        module3.py\n  docs/\n  tests/\n</code></pre> <p>In a Python module such as <code>core_one/src/core_one/module1.py</code>, there may be imports from other packages:</p> <pre><code># In core_one/src/core_one/module1.py\n\nfrom utility import utility_fn\n</code></pre> <p>Notice that this import path (<code>utility.utility_fn</code>) is rooted in the <code>utility/src</code> folder, NOT the project root.</p> <p>To indicate the project structure to Tach, you would set:</p> <pre><code>source_roots = [\n  \"utility/src\",\n  \"core_one/src\",\n  \"core_two/src\"\n]\n</code></pre> <p>in your <code>tach.toml</code>, or use <code>tach mod</code> and mark the same folders as source roots.</p> <p>Note</p> <pre><code>In `tach.toml`, each entry in `source_roots` is interpreted as a relative path from the project root.\n</code></pre> <p>After configuring your source roots as above, you can use <code>tach check-external</code> to validate that any dependencies between the packages are declared explicitly in the corresponding <code>pyproject.toml</code>.</p> <p>For example, given the import shown above (<code>core_one</code> importing from <code>utility</code>),</p> <pre><code># In core_one/src/core_one/module1.py\n\nfrom utility import utility_fn\n</code></pre> <p>Tach would validate that this is declared in <code>core_one/pyproject.toml</code>:</p> <pre><code># In core_one/pyproject.toml\n[project]\ndependencies = [\"myorg-utility\"]\n</code></pre> <p>Note that this also assumes the <code>name</code> of the <code>utility</code> package has been set to <code>myorg-utility</code>:</p> <pre><code># In utility/pyproject.toml\n[project]\nname = \"myorg-utility\"\n</code></pre>"},{"location":"usage/configuration/#tachdomaintoml","title":"<code>tach.domain.toml</code>","text":"<p>Tach allows splitting your configuration into 'domains', or sub-folders of your project. You can define modules and interfaces in a <code>tach.domain.toml</code> file which lives right next to the module code itself.</p> <p>This enables multiple developers or teams to independently own and maintain their modules and interfaces.</p>"},{"location":"usage/configuration/#modules_1","title":"Modules","text":"<p>Within a <code>tach.domain.toml</code> file, you can define modules similar to modules in <code>tach.toml</code>. The key difference is that paths are relative to the location of the domain by default, and there is a <code>[root]</code> module syntax for describing the parent folder itself.</p> <p>For example, a <code>tach.toml</code> file containing the module definitions: <pre><code>[[modules]]\npath = \"tach.filesystem\"\ndepends_on = [\n  \"tach.hooks\",\n  \"tach.filesystem.service\",\n]\n\n[[modules]]\npath = \"tach.filesystem.service\"\ndepends_on = []\n</code></pre></p> <p>could be expressed instead in a <code>tach.domain.toml</code> file at <code>&lt;source root&gt;/tach/filesystem/tach.domain.toml</code>:</p> <pre><code>[root]  # This defines \"tach.filesystem\"\ndepends_on = [\n  \"//tach.hooks\",  # This refers to \"tach.hooks\" (outside of this domain)\n  \"service\",  # This refers to \"tach.filesystem.service\"\n]\n\n[[modules]]\npath = \"service\"  # This defines \"tach.filesystem.service\"\ndepends_on = []\n</code></pre> <p>Note that the <code>tach.domain.toml</code> file uses its location relative to the nearest source root to implicitly determine its <code>[root]</code> module path (<code>\"tach.filesystem\"</code>).</p> <p>The domain configuration also uses special syntax to refer to dependencies on module paths outside of the domain, prefixing the absolute path with <code>\"//\"</code>.</p> <p>Module paths are generally interpreted relative to the location of the <code>tach.domain.toml</code> file, which can be seen in the definition for the <code>\"service\"</code> module. This path is interpreted relative to the domain root, meaning it refers to the <code>\"tach.filesystem.service\"</code> module.</p>"},{"location":"usage/configuration/#interfaces_1","title":"Interfaces","text":"<p>Interfaces are defined in largely the same way as in <code>tach.toml</code>, with the key difference being the treatment of paths in the <code>from</code> field. These will be interpreted as paths relative to the domain root.</p> <p>For example, a <code>tach.toml</code> file containing the interface definitions: <pre><code>[[interfaces]]\nexpose = [\"service.*\"]\nfrom = [\"tach.filesystem\"]\n\n[[interfaces]]\nexpose = [\"client.*\"]\nfrom = [\"tach.filesystem.git_ops\"]\n</code></pre></p> <p>could be expressed instead in a <code>tach.domain.toml</code> file at <code>&lt;source root&gt;/tach/filesystem/tach.domain.toml</code>:</p> <pre><code>[[interfaces]]\nexpose = [\"service.*\"]\nfrom = [\"&lt;domain_root&gt;\"]  # This matches \"tach.filesystem\"\n\n[[interfaces]]\nexpose = [\"client.*\"]\nfrom = [\"git_ops\"]  # This matches \"tach.filesystem.git_ops\"\n</code></pre>"},{"location":"usage/configuration/#example-codeowners","title":"Example: <code>CODEOWNERS</code>","text":"<p>Tach domain configuration files enable smooth integration with <code>CODEOWNERS</code>:</p> <pre><code># Domain ownership for different teams\n\n/tach.toml    @platform-team\n\n/payments/tach.domain.toml    @payments-team\n/auth/tach.domain.toml    @auth-team\n/data/analytics/tach.domain.toml    @analytics-team @data-team\n/mobile/tach.domain.toml    @mobile-team\n/libs/shared/tach.domain.toml    @platform-team\n</code></pre> <p>This allows a team to own their public interface, without imposing a bottleneck on other teams' configuration changes.</p>"},{"location":"usage/configuration/#external","title":"External","text":"<p>When running <code>check-external</code>, Tach allows excluding certain modules from validation.</p> <p>Adding the top level module name to the <code>exclude</code> key (underneath the <code>external</code> key) will allow all usages of the corresponding module.</p> <p>Example: <pre><code>[external]\nexclude = [\"PIL\"]\n</code></pre></p> <p>Tach also allows supplying a <code>rename</code> field to handle cases where the top level module name does not match the name of the package.</p> <p>For example, the <code>pillow</code> package supplies the <code>PIL</code> module, so Tach needs to map imports from <code>PIL</code> to the <code>pillow</code> package specifier in your requirements.</p> <pre><code>[external]\nrename = [\n  # Format \"[module name]:[package name]\"\n  \"PIL:pillow\",\n  ...\n]\n</code></pre> <p>In most cases you should not need to specify <code>rename</code> manually (see the Note below).</p> <p>Note</p> <pre><code>It is recommended to run Tach within a virtual environment containing all of\n</code></pre> <p>your dependencies across all packages. This is because Tach uses the   distribution metadata to map module names like 'git' to their distributions   ('GitPython').</p>"},{"location":"usage/configuration/#rules","title":"Rules","text":"<p>Tach allows configuring the severity of certain issues. Each entry in the <code>rules</code> table can be set to <code>error</code>, <code>warn</code>, or <code>off</code>.</p> <p>The available rules and their defaults are listed below.</p> <ul> <li><code>unused_ignore_directives</code> (default: <code>warn</code>): catch <code>tach-ignore</code> comments which are unused (e.g. do not suppress any errors or warnings)</li> <li><code>require_ignore_directive_reasons</code> (default: <code>off</code>): require every <code>tach-ignore</code> comment to have a reason</li> <li><code>unused_external_dependencies</code> (default: <code>error</code>): catch declared 3rd party dependencies which are not imported in your code</li> </ul>"},{"location":"usage/configuration/#cache","title":"Cache","text":"<p>Tach allows configuration of the computation cache it uses to speed up tasks like testing.</p> <p>The <code>file_dependencies</code> key accepts a list of glob patterns to indicate additional file contents that should be considered when checking for cache hits. This should typically include files outside of your source roots which affect your project's behavior under test, including the tests themselves. Additionally, if you have non-Python files which affect your project's behavior (such as Rust or C extensions), these should be included as well.</p> <p>The <code>env_dependencies</code> key accepts a list of environment variable names whose values affect your project's behavior under test. This may include a <code>DEBUG</code> flag, or database connection parameters in the case of tests which use a configurable database.</p>"},{"location":"usage/deprecate/","title":"Deprecate Dependencies","text":"<p>A dependency can be marked as <code>deprecated</code> - this means that the intention is to remove it over time, but it is still allowed. <code>tach check</code> will not error on deprecated dependencies, but it will surface each import that uses the deprecated dependency.</p>"},{"location":"usage/deprecate/#example","title":"Example","text":"<p>Given modules called 'core' and 'parsing':</p> <pre><code>[[modules]]\npath = \"parsing\"\ndepends_on = [\n    { path = \"core\", deprecated = true }\n]\n\n[[modules]]\npath = \"core\"\ndepends_on = []\n</code></pre> <p>Then, in <code>parsing.py</code>:</p> <pre><code>from core.main import get_data # we want to remove this!\n\nget_data()\n</code></pre> <p>This import won't fail <code>tach check</code>, instead you'll see: <pre><code>\u203c\ufe0f parsing.py[L1]: Import 'core.get_data' is deprecated. 'parsing' should not depend on 'core'.\n\u2705 All modules validated!\n</code></pre></p> <p>Note that we still see that all module dependencies are valid! To fail on the dependency, simply remove it from the <code>depends_on</code> key.</p>"},{"location":"usage/faq/","title":"FAQ","text":""},{"location":"usage/faq/#how-does-it-work","title":"How does it work?","text":"<p>Tach works by analyzing the imports in your Python modules. When you define dependencies in your project-level <code>tach.toml</code>, running <code>tach check</code> will verify that the imports in your modules match your expected dependencies.</p>"},{"location":"usage/faq/#what-is-a-module","title":"What is a module?","text":"<p>A 'module' is a Python module with dependencies configured in <code>tach.toml</code>. A module can be a python file or a directory. The module is identified by its import path from the nearest source root (e.g. <code>a.b</code> for <code>&lt;root&gt;/a/b.py</code>), and its dependencies can be listed in the <code>depends_on</code> key containing module paths in the same format.</p> <p>See more information on configuration here.</p>"},{"location":"usage/faq/#can-i-declare-a-module-without-restricting-its-dependencies","title":"Can I declare a module without restricting its dependencies?","text":"<p>Yes, you can remove the <code>depends_on</code> key from the module in your <code>tach.toml</code> configuration. Tach will then be aware of the module boundary so that it can be referenced in other modules' dependencies, even if you don't want to restrict the dependencies of the module itself.</p> <pre><code>[[modules]]\npath = \"my.module\"\n# no 'depends_on' key here means this module can depend on anything\n</code></pre>"},{"location":"usage/faq/#how-can-i-isolate-a-module-from-the-rest-of-the-code","title":"How can I isolate a module from the rest of the code?","text":"<p>To prevent any external usage of a given module, you can set <code>visibility: []</code> for the module in <code>tach.toml</code>. This means that no other module can declare an explicit dependency on this module.</p> <p>See more information on configuration here.</p>"},{"location":"usage/faq/#how-can-i-declare-modules-which-are-freely-usable-by-the-rest-of-the-code","title":"How can I declare modules which are freely usable by the rest of the code?","text":"<p>This is typically done for modules like <code>utils/</code>, <code>errors/</code> or <code>lib/</code>, which contain relatively isolated code which can be used throughout a project.</p> <p>Tach allows marking these modules as Utilities, which means they can be used without being listed as an explicit dependency.</p> <p>Note</p> <pre><code>Marking a module with `utility: true` is different from `visibility: ['*']`.\n</code></pre> <p>Even when a module has public visibility, other modules must declare an   explicit dependency to use it (in fact, modules are publicly visible by   default).</p> <p>In contrast, a utility module does not require its dependents to   list an explicit dependency.</p> <p>See more information on configuration here.</p>"},{"location":"usage/faq/#how-can-i-define-a-public-interface-for-a-module","title":"How can I define a public interface for a module?","text":"<p>Public interfaces are defined in tach.toml, and restrict the imports which are allowed from a given module. This is useful when you want to expose a stable API from a module and prevent other modules from becoming deeply coupled to its implementation details.</p> <p>See more information on configuration here.</p>"},{"location":"usage/faq/#are-conditional-imports-checked","title":"Are conditional imports checked?","text":"<p>Tach will check all imports in your source files, including those which are called conditionally. The only exceptions are imports made within <code>TYPE_CHECKING</code> conditional blocks. By default, Tach will not report errors from <code>TYPE_CHECKING</code> blocks. If you want to enable checks for these imports, you can add <code>ignore_type_checking_imports: false</code> to your <code>tach.toml</code>.</p> <p>See more information on configuration here.</p>"},{"location":"usage/faq/#can-you-catch-dynamic-references","title":"Can you catch dynamic references?","text":"<p>Since Tach uses the AST to find imports and public members, dynamic imports (e.g. using a string path) and dynamic names (e.g. using <code>setattr</code>, <code>locals</code>, <code>globals</code>) are not supported. If these usages cause Tach to report incorrect errors, the ignore directive should be sufficient to reach a passing state.</p>"},{"location":"usage/faq/#how-can-i-make-a-feature-request-or-file-a-bug","title":"How can I make a feature request or file a bug?","text":"<p>This project uses GitHub Issues to track bugs and feature requests. Search the existing issues before filing new issues to avoid duplicates. File your bug or feature request as a new Issue.</p>"},{"location":"usage/faq/#how-can-i-report-a-security-issue","title":"How can I report a security issue?","text":"<p>Do not report security vulnerabilities through public GitHub issues. Instead, please email us at caelean@gauge.sh or evan@gauge.sh.</p>"},{"location":"usage/faq/#what-information-does-tach-track","title":"What information does Tach track?","text":"<p>Tach tracks anonymized usage and error report statistics; we ascribe to Posthog's approach as detailed here. If you would like to opt out of sending anonymized info, you can set <code>disable_logging</code> to <code>true</code> in your <code>tach.toml</code>.</p>"},{"location":"usage/interfaces/","title":"Interfaces","text":"<p>A module can adopt a public interface by matching interface rules in <code>tach.toml</code>.</p>"},{"location":"usage/interfaces/#how-does-it-work","title":"How does it work?","text":"<p>When Tach is checking imports from a module with a public interface, it will verify that the import matches one of the <code>expose</code> patterns. This prevents other modules from becoming coupled to implementation details, and makes future changes easier.</p>"},{"location":"usage/interfaces/#example","title":"Example","text":"<p>Given modules called 'core' and 'domain', we may have <code>tach.toml</code> contents like this:</p> <pre><code>[[modules]]\npath = \"domain\"\ndepends_on = [\n    \"core\"\n]\n\n[[modules]]\npath = \"core\"\ndepends_on = []\n\n[[interfaces]]\nexpose = [\"get_data\"]\nfrom = [\"core\"]\n</code></pre> <p>Then, in <code>domain.py</code>, we may have:</p> <pre><code>from core.main import DataModel  # This import fails\n\nDataModel.objects.all()\n</code></pre> <p>This import would fail <code>tach check</code> with the following error:</p> <pre><code>\u274c domain.py[L1]: Module 'core' has a public interface. Only imports from the public interface of this module are allowed. The import 'core.main.DataModel' (in module 'parsing') is not public.\n</code></pre> <p>In this case, there is a public interface defined in <code>tach.toml</code> which includes a service method to use instead.</p> <pre><code>from core import get_data  # This import is OK\n\nget_data()\n</code></pre> <p><code>tach check</code> will now pass!</p> <pre><code>\u2705 All modules validated!\n</code></pre>"},{"location":"usage/interfaces/#interface-visibility","title":"Interface visibility","text":"<p>Interfaces can specify <code>visibility</code>, similar to modules.</p> <p>This allows 'splitting' the interface, usually to support a detailed/sensitive interface for some consumers while maintaining a minimal interface by default.</p>"},{"location":"usage/interfaces/#example_1","title":"Example","text":"<pre><code>[[modules]]\npath = \"api\"\ndepends_on = []\n\n[[interfaces]]\nexpose = [\"read_data\"]\nfrom = [\"api\"]\n\n[[interfaces]]\nexpose = [\"write_data\"]\nfrom = [\"api\"]\nvisibility = [\"admin.controller\"]  # limiting visibility of this interface\n</code></pre> <p>In the configuration shown above, the <code>api</code> module exposes only <code>read_data</code> to most consumers, while also providing <code>write_data</code> through an interface visible only to <code>admin.controller</code>.</p> <p>You may attach an arbitrary number of interfaces to the same module, with varying <code>visibility</code>.</p>"},{"location":"usage/interfaces/#example-exclusive-interface","title":"Example: Exclusive interface","text":"<p>It is also possible to mark an interface with <code>exclusive: true</code>.</p> <p>When an interface is <code>exclusive</code>, it will override all other matching interfaces for the module, which is only relevant when using <code>visibility</code> as shown above.</p> <p>Using the example above:</p> <pre><code>[[modules]]\npath = \"api\"\ndepends_on = []\n\n[[interfaces]]\nexpose = [\"read_data\"]\nfrom = [\"api\"]\n\n[[interfaces]]\nexpose = [\"write_data\"]\nfrom = [\"api\"]\nvisibility = [\"admin.controller\"]\nexclusive = true  # marking this interface as 'exclusive'\n</code></pre> <p>By marking the <code>write_data</code> interface as exclusive, we are saying that <code>admin.controller</code> should exclusively use <code>api</code> through that interface (e.g. <code>write_data</code>).</p>"},{"location":"usage/layers/","title":"Layers","text":"<p>An ordered list of layers can be configured at the top level of <code>tach.toml</code>, and modules can each be assigned to a specific layer.</p>"},{"location":"usage/layers/#how-does-it-work","title":"How does it work?","text":"<p>Layered architecture is often an effective starting point for modularizing an application.</p> <p>The idea is straightforward: Higher layers may import from lower layers, but lower layers may NOT import from higher layers.</p> <p>Defining this architecture is more concise and flexible than specifying all module dependencies with <code>depends_on</code>, which makes it easier to adopt in an existing project.</p> <p>Tach allows defining and enforcing a layered architecture with any number of vertically-stacked layers.</p> <p>When a module is assigned to a layer, this module: - may freely depend on modules in lower layers, without declaring these dependencies - must explicitly declare dependencies in its own layer - may never depend on modules in higher layers, even if they are declared</p>"},{"location":"usage/layers/#closed-layers","title":"Closed Layers","text":"<p>By default, modules in higher layers can import from any lower layer. However, you can mark a layer as \"closed\" to prevent modules in higher layers from importing modules in lower layers.</p> <p>For example, with layers A, B, and C (high to low), if B is a closed layer, then A cannot import C directly, even though C is lower than A. This is useful for enforcing strict boundaries between architectural tiers.</p> <p>When a layer is closed, it acts as an intermediary - modules in higher layers must go through the closed layer to access modules in lower layers. This helps enforce architectural boundaries and prevents direct coupling between distant layers.</p> <p>You can specify a closed layer by using an in-line object in the <code>layers</code> array:</p> <pre><code># Shorthand format (defaults to closed = false)\nlayers = [\"ui\", \"commands\", \"core\"]\n\n# Object format with closed property\nlayers = [\n    \"ui\",\n    { name = \"commands\", closed = true },\n    \"core\"\n]\n</code></pre> <p>In this example, if <code>commands</code> is a closed layer: - <code>ui</code> modules can import from <code>commands</code> modules - <code>commands</code> modules can import from <code>core</code> modules - <code>ui</code> modules CANNOT import directly from <code>core</code> modules - <code>ui</code> modules must go through <code>commands</code> modules to access <code>core</code> functionality</p>"},{"location":"usage/layers/#example","title":"Example","text":"<p>We can use the Tach codebase itself as an example of a 3-tier layered architecture:</p> <pre><code>layers = [\n  \"ui\",\n  \"commands\",\n  \"core\"\n]\n\n[[modules]]\npath = \"tach.check\"\nlayer = \"commands\"\n\n[[modules]]\npath = \"tach.cache\"\ndepends_on = [\"tach.filesystem\"]\nlayer = \"core\"\n\n[[modules]]\npath = \"tach.filesystem\"\ndepends_on = []\nlayer = \"core\"\n</code></pre> <p>In the configuration above, three layers are defined. They are similar to the classic <code>Presentation</code> - <code>Business Logic</code> - <code>Data</code> which are often found in web applications, but a bit different given that Tach is a CLI program.</p> <p>In Tach, the highest layer is <code>UI</code>, which includes code related to the CLI and other entrypoints to start the program.</p> <p>Just below this, the <code>Commands</code> layer contains high-level business logic which implements each of the CLI commands.</p> <p>At the bottom is the <code>Core</code> layer, which contains utilities, libraries, and broadly relevant data structures.</p> <p>Given this configuration, <code>tach.check</code> does not need to declare a dependency on <code>tach.cache</code> or <code>tach.filesystem</code> to use it, because the <code>Commands</code> layer is higher than the <code>Core</code> layer.</p> <p>However, <code>tach.cache</code> needs to explicitly declare its dependency on <code>tach.filesystem</code>, because they are both in the <code>Core</code> layer.</p>"},{"location":"usage/tach-ignore/","title":"tach-ignore","text":"<p>To ignore a particular import which should be allowed unconditionally, use the <code>tach-ignore</code> comment directive.</p> <pre><code># tach-ignore\nfrom core.main import private_function\n\nfrom core.api import private_calculation  # tach-ignore\n\nfrom core.package import (  # tach-ignore\n    service_one,\n    service_two\n)\n</code></pre> <p>The directive can also be specific about the import to ignore, which is particularly useful when importing multiple packages.</p> <pre><code># tach-ignore private_function\nfrom core.main import private_function, public_function\n\nfrom core.api import private_calculation, public_service  # tach-ignore private_calculation\n\nfrom core.package import (  # tach-ignore service_two\n    service_one,\n    service_two\n)\n</code></pre> <p>Note: Names given to <code>tach-ignore</code> should match the alias as it is used in the subsequent import line, not the full module path from the project root.</p>"},{"location":"usage/tach-ignore/#reasons","title":"Reasons","text":"<p>Tach also allows you to add a message next to the ignore directive, to document the reasoning for the ignore.</p> <pre><code># tach-ignore(Alternative API not yet available 11/26/24) private_api\nfrom core.api import private_api\n</code></pre>"},{"location":"usage/unchecked-modules/","title":"Unchecked Modules","text":"<p>A module can be marked 'unchecked' by setting <code>unchecked: true</code> in its configuration within <code>tach.toml</code>.</p>"},{"location":"usage/unchecked-modules/#how-does-it-work","title":"How does it work?","text":"<p>An unchecked module should be thought of as a 'known' module which does not have any restriction on its dependencies.</p> <p>The purpose of configuring an unchecked module is to better support incremental adoption of Tach.</p> <p>Note</p> <pre><code>Setting `unchecked: true` is different from omitting the `depends_on` field.\n</code></pre> <p>An unchecked module is allowed to import anything, from any module - even when the module declares a public interface.</p> <p>In contrast, a module with <code>depends_on</code> omitted will still need to respect public interfaces.</p>"},{"location":"usage/unchecked-modules/#example","title":"Example","text":"<p>Suppose you are adding Tach to an existing project, and you want to start by restricting dependencies for only one part of the codebase.</p> <pre><code>my_repo/\n  tach.toml\n  utils.py\n  filesytem/\n    service.py\n  parsing/\n    service.py\n  core/\n    module1.py\n    module2/\n      __init__.py\n      service.py\n    module3.py\n  docs/\n  tests/\n</code></pre> <p>Given the example project above, one might mark <code>utils</code>, <code>filesystem</code>, <code>parsing</code>, and <code>core.module(1,2,3)</code> as modules.</p> <p>After doing this, <code>tach sync</code> would detect and add all the dependencies found between these modules, and <code>tach check</code> would enforce them.</p> <p>However, suppose that <code>parsing</code>, <code>core.module2</code>, and <code>core.module3</code> are changing rapidly, and errors from <code>tach check</code> due to changing dependencies are unnecessary. By default, Tach would require the configuration to be 'all-or-nothing' - these errors would be unavoidable if these modules are themselves dependencies of more stable modules.</p> <pre><code>[[modules]]\npath = \"utils\"\nutility = true\ndepends_on = []\n\n[[modules]]\npath = \"filesystem\"\ndepends_on = []\n\n[[modules]]\n# this module is not checked because its errors would be noisy\npath = \"parsing\"\nunchecked = true\ndepends_on = []\n\n[[modules]]\n# Tach will verify this module's dependencies,\n# even though they are unchecked\npath = \"core.module1\"\ndepends_on = [\"core.module2\", \"core.module3\", \"parsing\"]\n\n[[modules]]\n# this module is not checked because its errors would be noisy\npath = \"core.module2\"\nunchecked = true\ndepends_on = []\n\n[[modules]]\n# this module is not checked because its errors would be noisy\npath = \"core.module3\"\nunchecked = true\ndepends_on = []\n</code></pre> <p>Using <code>unchecked: true</code> in the configuration above allows restricting dependencies for <code>core.module1</code> at a fine-grained level without needing to restrict dependencies for all other modules.</p>"},{"location":"usage/vscode/","title":"VSCode","text":"<p>Tach is installable as a VS Code extension which can be found here. Instructions for installation and setup are in the extension README and on the marketplace link.</p> <p>If you have any questions or run into any issues, let us know by submitting a Github Issue!</p>"}]}