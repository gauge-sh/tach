---
title: Overview
---

## What is Tach?

Tach allows you to control dependencies between your Python modules.
Modules can also define an explicit public interface to prevent deep coupling.

This creates a modular architecture, which makes development easier.

If a module tries to import from another module that is not listed as a dependency, Tach will report an error.

When a module is marked ['strict'](../usage/strict-mode), if another module tries to import from it without using its public interface, Tach will report an error.

Dependencies can be additionally marked as ['deprecated'](../usage/deprecate). Tach will not report an error but will surface usages of the deprecated dependency.

Tach is a CLI tool, and is ideal for pre-commit hooks and CI checks.

Tach is:

- üåé Open source
- üêç Installable via pip
- üîß Able to be adopted incrementally
- ‚ö° Implemented with no runtime impact
- ‚ôæÔ∏è Interoperable with your existing systems (cli, hooks, ci, etc.)

## Commands

- [`tach mod`](../usage/commands#tach-mod) - Interactively define module boundaries.
- [`tach check`](../usage/commands#tach-check) - Check that boundaries are respected.
- [`tach sync`](../usage/commands#tach-sync) - Sync constraints with the actual dependencies in your project.
- [`tach show`](../usage/commands#tach-show) - Visualize your project's dependency graph.
- [`tach report`](../usage/commands#tach-report) - Generate a dependency report for a file or module.
- [`tach test`](../usage/commands#tach-test) - Run only the tests impacted by your changes
- [`tach install`](../usage/commands#tach-install) - Install Tach into your development workflow (e.g. pre-commit)
